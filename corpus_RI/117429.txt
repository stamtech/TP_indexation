In graph theory, a '''tree decomposition''' is a mapping of a graph into a tree that can be used to speed up solving certain problems on the original graph. The '''treewidth''' measures the number of graph vertices mapped onto any tree node in an optimal tree decomposition.
While it is NP-hard to determine the treewidth of a graph, many NP-hard combinatorial problems on graphs are solvable in polynomial time when restricted to graphs of bounded treewidth.
In machine learning, tree decompositions are also called '''junction trees''', '''clique trees''', or '''join trees'''; they
The concept of tree decompositions and treewidth was introduced by  and has since been studied by many other authors.
Intuitively, a tree decomposition represents the vertices of the given graph as subtrees of a tree, in such a way that vertices are adjacent only when the corresponding subtrees intersect. Thus, the graph forms a subgraph of the intersection graph of the subtrees. The full intersection graph is a chordal graph.
Each subtree associates a graph vertex with a set of tree nodes. To define this formally, we represent each tree node as the set of vertices associated with it.
Thus, given a graph ''G'' = (''V'', ''E''), a tree decomposition is a pair (''X'', ''T''), where ''X'' = {''X''1, ..., ''X''''n''} is a family of subsets of ''V'', and ''T'' is a tree whose nodes are the subsets ''X''''i'', satisfying the following properties:
The tree decomposition of a graph is far from unique; for example, a trivial tree decomposition contains all vertices of the graph in its single root node.
The ''width'' of a tree decomposition is the size of its largest set ''X''''i'' minus one.   The '''treewidth''' tw(''G'') of a graph ''G'' is the minimum width among all possible tree decompositions of ''G''. In this definition, the size of the largest set is diminished by one in order to make the treewidth of a tree equal to one. Equivalently, the treewidth of ''G'' is one less than the size of the largest clique in any chordal graph containing ''G''. The graphs with treewidth at most ''k'' are also called partial ''k''-trees.
It is NP-complete to determine whether a given graph ''G'' has treewidth at most a given variable ''k''.
However, when ''k'' is any fixed constant, the graphs with treewidth ''k'' can be recognized, and a width ''k'' tree decomposition constructed for them, in linear time.. The time dependence of this algorithm on ''k'' is exponential.
Treewidth may also be characterized in terms of havens, functions describing an evasion strategy for a certain pursuit-evasion game defined on a graph. A graph ''G'' has treewidth ''k'' if and only if it has a haven of order  but of no higher order, where a haven of order  is a function ''  '' that maps each set ''X'' of at most ''k'' vertices in ''G'' into one of the connected components of  and that obeys the monotonicity property that  whenever 
For any fixed constant ''k'', the partial ''k''-trees are closed under the operation of graph minors, and therefore, by the Robertson   Seymour theorem, this family can be characterized in terms of a finite set of forbidden minors. For partial 1-trees (that is, forests), the single forbidden minor is a triangle, and for the partial 2-trees the single forbidden minor is the complete graph on four vertices. However, the number of forbidden minors increases for larger values of ''k'': for partial 3-trees there are four forbidden minors, the complete graph on five vertices, the octahedral graph with six vertices, the eight-vertex Wagner graph, and the pentagonal prism with ten vertices..
The planar graphs do not have bounded treewidth, because the ''n'' &times; ''n'' grid graph is a planar graph with treewidth ''n''. Therefore, if ''F'' is a minor-closed graph family with bounded treewidth, it cannot include all planar graphs. Conversely, if some planar graph cannot occur as a minor for graphs in family ''F'', then there is a constant ''k'' such that all graphs in ''F'' have treewidth at most ''k''. That is, the following three conditions are equivalent to each other:
Families of graphs with bounded treewidth include the cactus graphs, pseudoforests, series-parallel graphs, outerplanar graphs, and Halin graphs. The control flow graphs arising in the compilation of structured programs also have bounded treewidth, which allows certain tasks such as register allocation to be performed efficiently on them.
At the beginning of the 1970s, it was observed that a large class of combinatorial optimization problems defined on graphs could be efficiently solved by non serial dynamic programming as long as the graph had a bounded ''dimension'', a parameter related to treewidth. Later, several authors independently observed at the end of the 1980s that many algorithmic problems that are NP-complete for arbitrary graphs may be solved efficiently by dynamic programming for graphs of bounded treewidth, using the tree-decompositions of these graphs.
As an example, consider the problem of finding the maximum independent set in a graph of treewidth ''k''. To solve this problem, first choose one of the nodes of the tree decomposition to be the root, arbitrarily. For a node ''Xi'' of the tree decomposition, let ''Di'' be the union of the sets ''Xj'' descending from ''Xi''. Let ''A''(''S'',''i''), for an independent set ''S''&nbsp;   &nbsp;''Xi'', denote the size of the largest independent subset ''I'' of ''Di'' such that ''I''&nbsp;   &nbsp;''Xi''&nbsp;=&nbsp;''S''. Similarly, for an adjacent pair of nodes ''Xi'' and ''Xj'', with ''Xi'' farther from the root of the tree than ''Xj'', and an independent set ''S''&nbsp;   &nbsp;''Xi''&nbsp;   &nbsp;''Xj'', let ''B''(''S'',''i'',''j'') denote the size of the largest independent subset ''I'' of ''Di'' such that ''I''&nbsp;   &nbsp;''Xi''&nbsp;   &nbsp;''Xj''&nbsp;=&nbsp;''S''. We may calculate these ''A'' and ''B'' values by a bottom-up traversal of the tree:
At each node or edge, there are at most 2''k'' sets ''S'' for which we need to calculate these values, so if ''k'' is a constant then the whole calculation takes constant time per edge or node. The size of the maximum independent set is the largest value stored at the root node, and the maximum independent set itself can be found (as is standard in dynamic programming algorithms) by backtracking through these stored values starting from this largest value. Thus, in graphs of bounded treewidth, the maximum independent set problem may be solved in linear time. Similar algorithms apply to many other graph problems.
This dynamic programming approach is used in machine learning via the junction tree algorithm for belief propagation in graphs of bounded treewidth. It also plays a key role in algorithms for computing the treewidth and constructing tree decompositions: typically, such algorithms have a first step that approximates the treewidth, constructing a tree decomposition with this approximate width, and then a second step that performs dynamic programming in the approximate tree decomposition to compute the exact value of the treewidth.
In any tree decomposition (T, X) of a graph containing a clique there is a node ''i'' in ''T'' such that X_i contains all the  nodes of the clique. This is shown by induction on the size of the clique. The base cases are cliques of size 1 and 2, which follow from the conditions 1 and 2 on a tree decomposition. The inductive case is a graph containing a clique of size ''k''+1, where ''k'' is 2 or greater. Let ''C'' be the set of nodes in the clique. Since k+1 \geq 3, there are at least three nodes in the clique, call them ''x'', ''y'' and ''z''. We know from the induction hypothesis that there are nodes ''a'', ''b'' and ''c'' in the tree decomposition where 
In a tree there is exactly one path between any two nodes. A second property of trees is that the three paths between a, b and c have a non-empty intersection. Let v be a node in this intersection. From condition 3 on a tree decomposition we get that 
This implies that X_v \supseteq C.
It follows from this that the treewidth of a ''k''-clique is ''k''-1.
A connected graph with at least two vertices has treewidth 1 if and only if it is a tree. This can be shown in two steps, first that a tree has treewidth 1, second, that a connected graph with treewidth 1 is a tree. 
To show the former, use induction on the number of vertices in the tree to show that it has a tree decomposition with no bag with size larger than two. The base case is a  tree with  two vertices, in which case the tree decomposition with one single node is sufficient. The inductive case is a tree G with k+1 vertices, where k is any integer greater than 1. If we remove a leaf v from the graph, we get a tree of size k. From the induction hypothesis we can create a tree decomposition (T, X) of width 1 of this graph. Let u be the unique neighbour of v in G and i some node in T such that u is in X_i. Let T_1 be T added a node j with i as its only neighbour and let X' be X with the addition that X'_j = \{ i, j \} . Now (T_1, X') is a tree decomposition of G with width 1.
Now it remains to show that a connected graph with treewidth 1 is a tree. The contrapositive statement is that a graph with a cycle does not have treewidth 1. A graph with a cycle has the 3-clique as a minor, which from the statement in the previous section has treewidth 2. Since the partial 2-trees are closed under minors, the graph therefore has treewidth 2 or greater.